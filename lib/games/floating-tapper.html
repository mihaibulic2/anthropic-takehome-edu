<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Floating Tapper Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { 
      margin: 0; 
      padding: 0; 
      font-family: system-ui, -apple-system, sans-serif; 
      overflow: hidden;
    }
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
    .game-container.underwater {
      background: linear-gradient(180deg, #4facfe 0%, #00f2fe 100%);
      background-image: url('/games/assets/underwater-background.png');
    }
    .game-container.space {
      background: linear-gradient(180deg, #0c0c0c 0%, #1a1a2e 100%);
      background-image: url('/games/assets/space-background.png');
    }
    .game-container.forest {
      background: linear-gradient(180deg, #56ccf2 0%, #2f80ed 100%);
      background-image: url('/games/assets/forest-background.png');
    }
    .game-container.candy {
      background: linear-gradient(180deg, #ff9a9e 0%, #fecfef 100%);
      background-image: url('/games/assets/candy-background.png');
    }
    .floating-answer {
      position: absolute;
      width: 80px;
      height: 80px;
      background-color: black;
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      user-select: none;
      transition: transform 0.1s ease;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
    .floating-answer.styled {
      background-color: transparent;
      border-radius: 0;
    }
    .floating-answer:hover {
      transform: scale(1.1);
    }
    .floating-answer:active {
      transform: scale(0.95);
    }
    .question-display {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0,0,0,0.8);
      color: white;
      padding: 20px 40px;
      border-radius: 12px;
      font-size: 24px;
      font-weight: bold;
      z-index: 100;
      text-align: center;
      min-width: 300px;
    }
    .score-display {
      position: absolute;
      top: 20px;
      left: 20px;
      background-color: rgba(0,0,0,0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      font-size: 16px;
      z-index: 100;
    }
    .feedback {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      z-index: 200;
      animation: feedbackPop 1s ease-out;
    }
    .feedback.correct {
      color: #22c55e;
    }
    .feedback.incorrect {
      color: #ef4444;
    }
    @keyframes feedbackPop {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
    }
    .tap-animation {
      position: absolute;
      pointer-events: none;
      z-index: 150;
    }
    .tap-source {
      position: absolute;
      pointer-events: none;
      z-index: 50;
    }
    .tap-projectile {
      position: absolute;
      pointer-events: none;
      z-index: 140;
      opacity: 0;
      transition: all 0.5s ease;
    }
    .tap-effect {
      position: absolute;
      pointer-events: none;
      z-index: 160;
      opacity: 0;
      transform: scale(0);
      animation: tapEffect 0.6s ease-out;
    }
    @keyframes tapEffect {
      0% { opacity: 1; transform: scale(0); }
      50% { opacity: 1; transform: scale(1.2); }
      100% { opacity: 0; transform: scale(0.8); }
    }
    .game-complete {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      z-index: 500;
    }
    .complete-title {
      font-size: 48px;
      font-weight: bold;
      margin-bottom: 20px;
      color: #22c55e;
    }
    .complete-stats {
      font-size: 24px;
      text-align: center;
      line-height: 1.6;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script>
    const { useState, useEffect, useRef } = React;
    
    function FloatingTapperGame() {
      const [currentQuestion, setCurrentQuestion] = useState(null);
      const [questions, setQuestions] = useState([]);
      const [questionIndex, setQuestionIndex] = useState(0);
      const [floatingAnswers, setFloatingAnswers] = useState([]);
      const [score, setScore] = useState({ correct: 0, total: 0 });
      const [feedback, setFeedback] = useState(null);
      const [gameComplete, setGameComplete] = useState(false);
      const [gameStarted, setGameStarted] = useState(false);
      const [tapAnimation, setTapAnimation] = useState(null);
      const animationFrameRef = useRef();
      const containerRef = useRef();
      
      // Game props injected by server
      const props = {{GAME_PROPS}};
      
      // Get style or default to underwater
      const selectedStyle = props.selectedStyle || 'underwater';
      
      // Style configurations
      const styleConfigs = {
        underwater: {
          answerAssets: ['underwater-answer1.png', 'underwater-answer2.png', 'underwater-answer3.png'],
          sourceAsset: 'underwater-source.png',
          projectileAsset: 'underwater-projectile.png',
          effectAsset: 'underwater-effect.png'
        },
        space: {
          answerAssets: ['space-answer1.png', 'space-answer2.png'],
          sourceAsset: 'space-source.png',
          projectileAsset: 'space-projectile.png',
          effectAsset: 'space-effect.png'
        },
        forest: {
          answerAssets: ['forest-answer1.png', 'forest-answer2.png', 'forest-answer3.png'],
          sourceAsset: 'forest-source.png',
          projectileAsset: 'forest-projectile.png',
          effectAsset: 'forest-effect.png'
        },
        candy: {
          answerAssets: ['candy-answer1.png', 'candy-answer2.png', 'candy-answer3.png'],
          effectAsset1: 'candy-effect1.png',
          effectAsset2: 'candy-effect2.png',
          projectileAsset: 'candy-projectile.png'
        }
      };
      
      const currentConfig = styleConfigs[selectedStyle] || styleConfigs.underwater;
      
      // Initialize game
      useEffect(() => {
        // Initialize stats tracking
        GameUtils.initializeStats(props.gameId, props.selectedStyle);
        
        // Setup close detection to send stats when game closes
        GameUtils.setupCloseDetection();
        
        // Get questions from shared utils
        const gameQuestions = GameUtils.getQuestions(8);
        setQuestions(gameQuestions);
        
        // Start first question
        if (gameQuestions.length > 0) {
          startQuestion(gameQuestions[0], 0);
          setGameStarted(true);
        }
        
        // Start animation loop
        animationFrameRef.current = requestAnimationFrame(updateFloatingAnswers);
        
        return () => {
          if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
          }
        };
      }, []);
      
      const startQuestion = (question, index) => {
        setCurrentQuestion(question);
        setQuestionIndex(index);
        
        // Create floating answers based on style
        const containerWidth = window.innerWidth;
        const containerHeight = window.innerHeight;
        
        const answers = GameUtils.shuffleArray(question.answers).map((answer, i) => {
          const position = GameUtils.getRandomPosition(containerWidth, containerHeight, 80, 80, 100);
          const assetIndex = i % currentConfig.answerAssets.length;
          const asset = currentConfig.answerAssets[assetIndex];
          
          let motionData = {};
          
          // Style-specific initialization
          if (selectedStyle === 'underwater') {
            // Sine/cosine swimming
            motionData = {
              baseSpeed: 0.5 + Math.random() * 1.5,
              amplitude: 30 + Math.random() * 40,
              frequency: 0.02 + Math.random() * 0.03,
              phase: Math.random() * Math.PI * 2,
              direction: Math.random() < 0.5 ? 1 : -1
            };
          } else if (selectedStyle === 'space') {
            // Zero-G drift
            const velocity = GameUtils.getRandomVelocity(0.3, 1.5);
            motionData = {
              vx: velocity.vx,
              vy: velocity.vy,
              rotation: 0,
              rotationSpeed: (Math.random() - 0.5) * 2
            };
          } else if (selectedStyle === 'forest') {
            // Animal wandering
            motionData = {
              targetX: Math.random() * (containerWidth - 80),
              targetY: 100 + Math.random() * (containerHeight - 180),
              speed: 0.5 + Math.random() * 1,
              waitTime: 0,
              pauseDuration: 60 + Math.random() * 120,
              moving: true
            };
          } else if (selectedStyle === 'candy') {
            // Bouncing physics
            const velocity = GameUtils.getRandomVelocity(1, 3);
            motionData = {
              vx: velocity.vx,
              vy: velocity.vy,
              bounceStrength: 0.8 + Math.random() * 0.4,
              gravity: 0.1
            };
          }
          
          return {
            id: i,
            text: answer,
            x: position.x,
            y: position.y,
            asset: asset,
            isCorrect: answer === question.answers[question.correctAnswerIndex],
            time: 0,
            ...motionData
          };
        });
        
        setFloatingAnswers(answers);
      };
      
      const updateFloatingAnswers = () => {
        if (!gameStarted || gameComplete) return;
        
        setFloatingAnswers(prev => {
          return prev.map(answer => {
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight;
            const answerSize = 80;
            const padding = 20;
            
            let updates = { time: answer.time + 1 };
            
            if (selectedStyle === 'underwater') {
              // Sine/cosine swimming motion
              const newTime = answer.time + 1;
              const baseX = answer.x + answer.baseSpeed * answer.direction;
              const offsetY = Math.sin(newTime * answer.frequency + answer.phase) * answer.amplitude;
              
              let newX = baseX;
              let newY = answer.y + offsetY * 0.1;
              
              // Wrap around horizontally
              if (newX > containerWidth) newX = -answerSize;
              if (newX < -answerSize) newX = containerWidth;
              
              // Keep in bounds vertically
              newY = Math.max(100 + padding, Math.min(containerHeight - answerSize - padding, newY));
              
              updates = { ...updates, x: newX, y: newY };
              
            } else if (selectedStyle === 'space') {
              // Zero-G drift with bouncing
              let newX = answer.x + answer.vx;
              let newY = answer.y + answer.vy;
              let newVx = answer.vx;
              let newVy = answer.vy;
              let newRotation = answer.rotation + answer.rotationSpeed;
              
              // Bounce off walls
              if (newX <= padding || newX >= containerWidth - answerSize - padding) {
                newVx = -answer.vx;
                newX = Math.max(padding, Math.min(containerWidth - answerSize - padding, newX));
              }
              
              if (newY <= padding + 100 || newY >= containerHeight - answerSize - padding) {
                newVy = -answer.vy;
                newY = Math.max(padding + 100, Math.min(containerHeight - answerSize - padding, newY));
              }
              
              updates = { ...updates, x: newX, y: newY, vx: newVx, vy: newVy, rotation: newRotation };
              
            } else if (selectedStyle === 'forest') {
              // Animal wandering behavior
              let newX = answer.x;
              let newY = answer.y;
              let moving = answer.moving;
              let waitTime = answer.waitTime;
              let targetX = answer.targetX;
              let targetY = answer.targetY;
              
              if (moving) {
                // Move toward target
                const dx = targetX - answer.x;
                const dy = targetY - answer.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < answer.speed) {
                  // Reached target, start waiting
                  newX = targetX;
                  newY = targetY;
                  moving = false;
                  waitTime = answer.pauseDuration;
                } else {
                  // Move toward target with slight waddle
                  const waddle = Math.sin(answer.time * 0.3) * 2;
                  newX += (dx / distance) * answer.speed + waddle * 0.5;
                  newY += (dy / distance) * answer.speed;
                }
              } else {
                // Waiting/pausing
                waitTime--;
                if (waitTime <= 0) {
                  // Pick new target
                  targetX = Math.random() * (containerWidth - answerSize);
                  targetY = 100 + Math.random() * (containerHeight - 180);
                  moving = true;
                }
              }
              
              updates = { ...updates, x: newX, y: newY, moving, waitTime, targetX, targetY };
              
            } else if (selectedStyle === 'candy') {
              // Bouncing physics
              let newX = answer.x + answer.vx;
              let newY = answer.y + answer.vy;
              let newVx = answer.vx;
              let newVy = answer.vy + answer.gravity;
              
              // Bounce off walls
              if (newX <= padding || newX >= containerWidth - answerSize - padding) {
                newVx = -answer.vx * answer.bounceStrength;
                newX = Math.max(padding, Math.min(containerWidth - answerSize - padding, newX));
              }
              
              if (newY <= padding + 100) {
                newVy = Math.abs(newVy) * answer.bounceStrength;
                newY = padding + 100;
              }
              
              if (newY >= containerHeight - answerSize - padding) {
                newVy = -Math.abs(newVy) * answer.bounceStrength;
                newY = containerHeight - answerSize - padding;
              }
              
              updates = { ...updates, x: newX, y: newY, vx: newVx, vy: newVy };
            }
            
            return { ...answer, ...updates };
          });
        });
        
        animationFrameRef.current = requestAnimationFrame(updateFloatingAnswers);
      };
      
      const playTapAnimation = (targetAnswer) => {
        const containerWidth = window.innerWidth;
        const containerHeight = window.innerHeight;
        
        let animationData = {};
        
        if (selectedStyle === 'underwater') {
          // Fishing rod animation
          animationData = {
            sourceX: containerWidth / 2 - 60,
            sourceY: 20,
            targetX: targetAnswer.x + 40,
            targetY: targetAnswer.y + 40,
            projectileAsset: currentConfig.projectileAsset,
            effectAsset: currentConfig.effectAsset
          };
        } else if (selectedStyle === 'space') {
          // Laser beam animation
          animationData = {
            sourceX: containerWidth / 2 - 50,
            sourceY: 20,
            targetX: targetAnswer.x + 40,
            targetY: targetAnswer.y + 40,
            projectileAsset: currentConfig.projectileAsset,
            effectAsset: currentConfig.effectAsset
          };
        } else if (selectedStyle === 'forest') {
          // Bird swoop animation
          const randomBranchX = Math.random() * (containerWidth - 200);
          animationData = {
            sourceX: randomBranchX,
            sourceY: 50,
            targetX: targetAnswer.x + 40,
            targetY: targetAnswer.y + 40,
            projectileAsset: currentConfig.projectileAsset,
            effectAsset: currentConfig.effectAsset
          };
        } else if (selectedStyle === 'candy') {
          // Sparkle/pop animation
          animationData = {
            targetX: targetAnswer.x + 40,
            targetY: targetAnswer.y + 40,
            effectAsset: currentConfig.effectAsset1
          };
        }
        
        setTapAnimation(animationData);
        
        // Clear animation after duration
        setTimeout(() => setTapAnimation(null), 600);
      };

      const handleAnswerClick = (answer) => {
        const isCorrect = answer.isCorrect;
        
        // Play tap animation
        playTapAnimation(answer);
        
        // Track the answer
        GameUtils.trackAnswer(isCorrect);
        
        // Update score
        setScore(prev => ({
          correct: prev.correct + (isCorrect ? 1 : 0),
          total: prev.total + 1
        }));
        
        // Show feedback
        setFeedback(isCorrect ? 'correct' : 'incorrect');
        setTimeout(() => setFeedback(null), 1000);
        
        // Move to next question or end game
        setTimeout(() => {
          const nextIndex = questionIndex + 1;
          if (nextIndex < questions.length) {
            startQuestion(questions[nextIndex], nextIndex);
          } else {
            // Game complete
            setGameComplete(true);
            GameUtils.sendGameStats(true);
          }
        }, 1000);
      };
      
      const getAccuracyPercent = () => {
        return score.total > 0 ? Math.round((score.correct / score.total) * 100) : 0;
      };
      
      if (gameComplete) {
        const stats = GameUtils.getCurrentStats();
        return React.createElement('div', {
          className: 'game-complete'
        }, [
          React.createElement('div', {
            key: 'title',
            className: 'complete-title'
          }, 'Great Job!'),
          React.createElement('div', {
            key: 'stats',
            className: 'complete-stats'
          }, [
            React.createElement('div', { key: 'score' }, `Score: ${score.correct} out of ${score.total}`),
            React.createElement('div', { key: 'accuracy' }, `Accuracy: ${getAccuracyPercent()}%`),
            React.createElement('div', { key: 'time' }, `Time: ${Math.round(stats.timeSpent)} seconds`)
          ])
        ]);
      }
      
      if (!gameStarted || !currentQuestion) {
        return React.createElement('div', {
          className: 'game-container',
          style: { display: 'flex', alignItems: 'center', justifyContent: 'center' }
        }, React.createElement('div', {
          style: { fontSize: '24px', fontWeight: 'bold' }
        }, 'Loading game...'));
      }
      
      return React.createElement('div', {
        className: `game-container ${selectedStyle}`,
        ref: containerRef
      }, [
        // Source element (boat, spaceship, branch, etc.)
        selectedStyle !== 'candy' && currentConfig.sourceAsset && React.createElement('div', {
          key: 'source',
          className: 'tap-source',
          style: {
            left: selectedStyle === 'forest' ? '20px' : '50%',
            top: selectedStyle === 'forest' ? '50px' : '110px',
            transform: selectedStyle === 'forest' ? 'none' : 'translateX(-50%)',
            width: selectedStyle === 'forest' ? '200px' : '120px',
            height: selectedStyle === 'forest' ? '30px' : '80px',
            backgroundImage: `url('/games/assets/${currentConfig.sourceAsset}')`,
            backgroundSize: 'cover',
            backgroundPosition: 'center',
            backgroundRepeat: 'no-repeat'
          }
        }),
        
        // Question display
        React.createElement('div', {
          key: 'question',
          className: 'question-display'
        }, currentQuestion.question),
        
        // Score display
        React.createElement('div', {
          key: 'score',
          className: 'score-display'
        }, [
          React.createElement('div', { key: 'score-text' }, `Score: ${score.correct}/${score.total}`),
          React.createElement('div', { key: 'question-number' }, `Question ${questionIndex + 1}/${questions.length}`)
        ]),
        
        // Floating answers
        ...floatingAnswers.map(answer => {
          const answerStyle = {
            left: `${answer.x}px`,
            top: `${answer.y}px`
          };
          
          if (answer.asset) {
            answerStyle.backgroundImage = `url('/games/assets/${answer.asset}')`;
            answerStyle.backgroundSize = 'cover';
            answerStyle.backgroundPosition = 'center';
            answerStyle.backgroundRepeat = 'no-repeat';
          }
          
          if (selectedStyle === 'space' && answer.rotation !== undefined) {
            answerStyle.transform = `rotate(${answer.rotation}deg)`;
          }
          
          const className = answer.asset ? 'floating-answer styled' : 'floating-answer';
          
          return React.createElement('div', {
            key: answer.id,
            className: className,
            style: answerStyle,
            onClick: () => handleAnswerClick(answer)
          }, !answer.asset ? answer.text : React.createElement('div', {
            style: {
              position: 'absolute',
              bottom: '5px',
              left: '50%',
              transform: 'translateX(-50%)',
              background: 'rgba(0,0,0,0.8)',
              color: 'white',
              padding: '2px 8px',
              borderRadius: '4px',
              fontSize: '14px',
              fontWeight: 'bold'
            }
          }, answer.text));
        }),
        
        // Tap animations
        tapAnimation && [
          // Projectile (fishing line, laser, bird)
          tapAnimation.projectileAsset && React.createElement('div', {
            key: 'projectile',
            className: 'tap-projectile',
            style: {
              left: `${tapAnimation.sourceX || tapAnimation.targetX}px`,
              top: `${tapAnimation.sourceY || tapAnimation.targetY}px`,
              width: selectedStyle === 'space' ? '10px' : selectedStyle === 'underwater' ? '200px' : '80px',
              height: selectedStyle === 'space' ? '200px' : selectedStyle === 'underwater' ? '20px' : '40px',
              backgroundImage: `url('/games/assets/${tapAnimation.projectileAsset}')`,
              backgroundSize: 'cover',
              backgroundPosition: 'center',
              backgroundRepeat: 'no-repeat',
              transform: selectedStyle === 'space' ? 
                `rotate(${Math.atan2(tapAnimation.targetY - tapAnimation.sourceY, tapAnimation.targetX - tapAnimation.sourceX) * 180 / Math.PI + 90}deg)` :
                selectedStyle === 'underwater' ?
                `rotate(${Math.atan2(tapAnimation.targetY - tapAnimation.sourceY, tapAnimation.targetX - tapAnimation.sourceX) * 180 / Math.PI}deg)` :
                'none',
              opacity: 1,
              transition: 'all 0.5s ease'
            }
          }),
          
          // Effect at target
          React.createElement('div', {
            key: 'effect',
            className: 'tap-effect',
            style: {
              left: `${tapAnimation.targetX - 50}px`,
              top: `${tapAnimation.targetY - 50}px`,
              width: '100px',
              height: '100px',
              backgroundImage: `url('/games/assets/${tapAnimation.effectAsset}')`,
              backgroundSize: 'cover',
              backgroundPosition: 'center',
              backgroundRepeat: 'no-repeat'
            }
          })
        ],
        
        // Feedback
        feedback && React.createElement('div', {
          key: 'feedback',
          className: `feedback ${feedback}`
        }, feedback === 'correct' ? '✓ Correct!' : '✗ Try Again!')
      ]);
    }
    
    // Render the game
    ReactDOM.render(React.createElement(FloatingTapperGame), document.getElementById('root'));
  </script>
</body>
</html>